import unittest
import sys
import os
import asyncio
from unittest.mock import MagicMock, AsyncMock, patch
from langchain_core.messages import AIMessage

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from src.agents.conclusion_agent import ConclusionAgent

class TestConclusionStream(unittest.IsolatedAsyncioTestCase):
    def setUp(self):
        self.mock_model = MagicMock()
        self.agent = ConclusionAgent(self.mock_model)

    @patch('src.agents.conclusion_agent.ChatPromptTemplate')
    async def test_generate_report_stream(self, mock_prompt_cls):
        # Mock summary generation
        mock_chain = MagicMock()
        mock_chain.ainvoke = AsyncMock(return_value=AIMessage(content="Summary Text"))
        
        # Mock refine chain
        async def mock_astream(*args, **kwargs):
            # args[0] contains the input dict
            input_dict = args[0] if args else {}
            title = input_dict.get('title', 'Unknown')
            yield AIMessage(content=f'<section title="{title}">\n<text>\nRefined Content\n</text>\n<sources></sources>\n</section>')
        mock_chain.astream = mock_astream
        
        mock_prompt = MagicMock()
        mock_prompt.__or__.return_value = mock_chain
        mock_prompt_cls.from_messages.return_value = mock_prompt

        sections = [
            {
                "title": "Section 1", 
                "content": "Content 1", 
                "sources": [{"url": "http://a.com", "title": "A"}]
            },
            {
                "title": "Section 2", 
                "content": "Content 2", 
                "sources": [{"url": "http://a.com", "title": "A"}, {"url": "http://b.com", "title": "B"}]
            }
        ]

        chunks = []
        async for chunk in self.agent.generate_report_stream("Test Query", sections):
            chunks.append(chunk)

        full_output = "".join(chunks)

        # Verify Summary
        self.assertIn('<section title="Executive Summary">', full_output)
        self.assertIn('Summary Text', full_output)
        
        # Verify Section 1
        self.assertIn('<section title="Section 1">', full_output)
        self.assertIn('Refined Content', full_output)
        
        # Verify Sources (Deduplicated)
        # In the new implementation, sources are inside the section XML generated by LLM
        # Our mock returns <sources></sources>, so we can only check for that or update mock
        self.assertIn('<sources></sources>', full_output)

if __name__ == '__main__':
    unittest.main()
